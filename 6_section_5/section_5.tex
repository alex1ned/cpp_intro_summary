\section{Files and streams}

\begin{itemize}
	\item A file is just a linear sequence of \emph{characters}.
	\item A stream is a channel on which data is passed from senders to receivers.
	\item Streams allow travel in only one direction (out from the program on an output
	stream or received from the program on an input stream.
	\item The standard input stream \emph{cin} is connected to the keyboard and 
	the standard output stream is connected to the monitor \emph{cout}.
	\item To use streams we need to include the \emph{fstream} header file.
\end{itemize}


\subsection{Creating \& opening streams and checking for failure}
\subsubsection*{Creating a stream}

Creating a stream is a bid like a variable declaration. The below creates an instance of the
the class \emph{ifstream}, called in\_stream, and \emph{ofstream}, called out\_stream.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
#include <fstream>

ifstream in_stream;
ofstream out_stream;
\end{minted}
\caption{Creating a stream}
\label{source_code}
\end{listing}

\subsubsection*{Connecting and disconnecting streams to files}
Use the member functions \emph{open} and \emph{close} - remember to always close. Also note that
when opening an output stream, the contents of the file are deleted and is then ready for new input.
Closing an output stream will also put an EOF marker at the end.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
in_stream.open("filename.txt");
out_stream.open("other_filename.txt");

//Remember to always close ...
in_stream.close();
out_stream.close();
\end{minted}
\caption{Connecting and disconnecting streams}
\label{source_code}
\end{listing}

To \emph{append} to an output stream (thus not to overwrite), open it using the following line:
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
out_stream.open("some_file.txt', ios::app); //requires iostream
\end{minted}


\subsubsection*{Checking for failure with file commands}
Use the member function \emph{.fail( )} -- can do this with input and output streams. Place this statement
immediately after opening a stream.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
#include <iostream>
#include <fstream>
#include <cstdlib>

int main()
{
	ifstream in;
	
	in.open("some_text.csv");
	if (in_stream.fail())
	{
		cout << "Sorry, the file was not opened!" << endl;
		exit(1);
	}
	...
}
\end{minted}
\caption{Checking for failure when opening a stream}
\label{source_code}
\end{listing}


%--------------------------------------------------------------------------------------------

\subsection{Character input and output and checking for end-of-file}
You can get or put characters one at a time using the member functions \emph{get} and
\emph{put} (or also \emph{putback}. Alternatively you can use the operators \emph{\textless\textless} or
\emph{\textgreater\textgreater} to read in or put out blocks of characters (useful for numbers).

\subsubsection*{Input/output with get, put, putback}
The functions take a single argument of type \emph{char} and always only handle one character
at a time (where an empty space or new line etc. are also all chars. 

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
char character;
in_stream.get(character);
	//gets the next character of the input file whose value is assigned to the character
	
out_stream.put('4'); //puts 4 as a type character into the output file
//OR
out_stream.put(character); //puts a character into the output file


in_stream.putback(character);
	//Puts the character implicitly back into the input file and repositions to this character
in_stream.putback('7');
	//Can also put another character pack to the input file
	//NOTE that both do not alter the actual input file (this is just implicit).

\end{minted}
\caption{Illustration of character input/output using get and put}
\label{source_code}
\end{listing}


\subsubsection*{Input/output with the operators \textless\textless and \textgreater\textgreater}
The problem we have is that some data types, such as int, double etc., have to be converted into
character sequences before they can be written to a file, and these character sequences have to be
converted back again when they are input. The operators \textless\textless and \textgreater\textgreater
do some of this conversion automatically.

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
out_stream << 437 << ' ';
	//Here the characters '4' '3' '7' are output to the file and end with an empty character 
\end{minted}

For input streams you could also read in numbers with it - note that the \textless\textless skips
over blank space (irrespective of the data type).

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
int number;
in_stream >> number;
\end{minted}

You can also read in ever other item using the syntax below \ldots

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
int number;
in_stream >> number >> number;
//if you use 'number' now in a loop it will be every other number ....
\end{minted}


Here you see an example where you try to read in five (two-digit) numbers as either ints or chars.
When reading them in as ints the count is 5 \ldots using chars the count is 10 - in both
cases whitespace is stripped and empty characters are not counted.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
int main()
{
    char character;
    int number = 51;
    int count = 0;
    ofstream out_stream;
    ifstream in_stream1;   //Stream for counting integers
    ifstream in_stream2;   //Stream for counting characters

    //Create the file
    out_stream.open("Integers");
    for (count = 1 ; count <= 5 ; count++)
        out_stream << number++ << ' ';
    out_stream.close();
    
    //Count the integers
    in_stream1.open("Integers");
    count = 0;
    in_stream1 >> number;
    while (!in_stream1.fail())
    {
        count++;
        in_stream1 >> number;
    }
    in_stream1.close();
    cout << "There are " << count << " integers in the file,\n";
    
    //Count the characters
    in_stream2.open("Integers");
    count = 0;
    in_stream2 >> character;
    while (!in_stream2.fail())
    {
        count++;
        in_stream2 >> character;
    }
    in_stream2.close();
    cout << "represented using " << count << " characters.\n";
}
\end{minted}
\caption{Illustration of character input/output using \textless\textless and \textgreater\textgreater}
\label{source_code}
\end{listing}




\subsubsection*{Checking for the end of and input file (eof)}
Once an in-stream reaches the eof, no attempt should be made to read from the file, since the results will
be unpredictable. To check if the eof is reached, the boolean expression \emph{in\_stream.eof()} would be true.

The below is an important example with a common loop structure. The code reads in a text file and outputs
each character to the screen and to a copy file.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
	char character;
	ifstream in_stream;
	ofstream out_stream;

	in_stream.open("file.cpp");
	out_stream.open("Copy_of_file");
	
	// ... could check for failure to open stream here ...
	
	in_stream.get(character); // !!! get char here first once
	while (!in_stream.eof()) 
	{	//while we are not at the end-of-file
		cout << character;
		out_stream.put(character);
		in_stream.get(character); // !!! get char here again
	}
	
	out_stream.close(); //always close
	in_stream.close(); //always close
}
\end{minted}
\caption{Checking for EOF when using input streams}
\label{source_code}
\end{listing}

%--------------------------------------------------------------------------------------------

\subsection{Streams as arguments to functions}
Streams \emph{must} be reference parameters in functions.

Below is a the same code, that reads a text-file and copies the content to a new file and
outputs the contents to the monitor - but here a function \emph{copy\_to( ... )} is used.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
#include <iostream>
#include <fstream>

using namespace std;

void copy_to(ifstream& in, ofstream& out);

int main()
{
	ifstream in_stream;
	ofstream out_stream;

	in_stream.open("4-6-1.cpp");
	out_stream.open("Copy_of_4");
	
	copy_to(in_stream, out_stream);	
	
	out_stream.close();
	in_stream.close();

	return 0;
}

void copy_to(ifstream& in, ofstream& out)
{
	char character;
	in.get(character);
	while (!in.fail())
	{
		cout << character;
		out.put(character);
		in.get(character);
	}
}
\end{minted}
\caption{Streams as arguments to functions - use as reference parameters}
\label{source_code}
\end{listing}


%--------------------------------------------------------------------------------------------

\subsection{Formatting when using output streams}

\subsubsection*{Member function - .precision( integer )}
Using the \emph{precision} member function will result in all numbers output
on that stream to be shown to a certain digit (argument used for integer).

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
out_stream.precision(2);
\end{minted}


\subsubsection*{Flag member function - .setf(some argument here)}

\begin{table}[h]
\begin{center}
\renewcommand{\arraystretch}{1.8}
\begin{tabular}{ m{2.5cm} m{10cm}} 
\textbf{Flag} & \textbf{Meaning}\\
\hline
ios::fixed & Floating point numbers are not written in scientific notation.\\
\hline

ios::scientific & Floating point numbers are not written in e-notation (if neither this
or the above is set, the system will decide which to use).\\
\hline

ios::showpoint & A decimal point and trailing zeros are always shown for floats.\\
\hline

ios::showpos & A plus sign is output before positive integer values\\
\hline

ios::right & Item will be at right end of the space (default case) - thus right-justified\\
\hline

ios::left & Item will be left-justified\\
\hline

\hline
\end{tabular}
\end{center}
\caption{Common flags for output streams}
\label{table_1}
\end{table}




