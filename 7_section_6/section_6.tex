\section{Arrays and c-strings}

%-----------------------------------------------------
\subsection{Basics of arrays}
Syntax for declaring an array is \ldots

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
//Declaration:
<type of elements> <variable name>[integer value];

//Initialisation - v01:
int numbers[3] = {1, 10, 15};
//Initialisation - v02:
int numbers[] = {1, 10, 15};

//Some examples
int numbers[10];
	//an array that holds 10 integers

char characters[5];
	//an array that holds 5 characters

double* real_numbers[3];
	//an array that holds 3 pointers to variables of type double
	//... since an array is like a pointer variable, it could also be
	//... an array of 3 arrays that hold doubles

int** some_array[8];
	//an array that holds 8 pointers to pointers to variables of type int
	//is like an array of arrays of arrays
	// ... similar to a two-dimensional array 
\end{minted}

\noindent
Could use a \emph{typedef} if we declare the same array structure many times.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
const int NUMBER = 6;
typedef int Hours_array[NUMBER]; //Hours_array is then like a type

Hours_array hours; //hours is now an array that holds 6 integers
Hours_array hours_w2; //hours_w2 is now an array that holds 6 integers
\end{minted}
\caption{Using a typedef for arrays}
\label{source_code}
\end{listing}



\subsubsection*{Example of assigning the elements of an array with user input}
Note that you cannot simply assign an array but only its elements (typically using a loop).

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
int main()
{
	int hours[6];
	int count;
	
	for (count = 1 ; count <= NO_OF_EMPLOYEES ; count++)
	{
		cout << "Enter hours for employee number " << count << ": ";
		cin >> hours[count - 1];
	}
}
\end{minted}
\caption{Assigning each element of an array with user input}
\label{source_code}
\end{listing}

Note that C++ does not do range bound error checking - thus does not warn you when you try
to access an element outside of the array (given an array is just the address of the first element
of the array). To avoid the possibility of a range bound error you can make a condition in the loops
that does not modify anything below or above the number of elements of the array \ldots such as \ldots
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
for (int i = 0; !in.eof() && i < MAX; i++)
{
	//Do something here
}
\end{minted}



\subsubsection*{Range based for-loop for arrays}
\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
int array[] = {2, 4, 6, 8};
for (int x : array)
{
	cout << x;
}
\end{minted}
\caption{Range based for-loop for arrays}
\label{source_code}
\end{listing}

This can also be based by reference \ldots
\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
int array[] = {2, 4, 6, 8};
for (int& x : array)
{
	x++;
}
	for (auto x : array)
{
	cout << x;
}
// will output 3579
\end{minted}
\caption{Range based for-loop for arrays passed by reference}
\label{source_code}
\end{listing}


\subsubsection*{Example of a code that prints itself out (uses files and arrays of chars)}
\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
#include <fstream>

const int MAX = 1000;

int main()
{
	int count;
	char character;
	int file[MAX];
	ifstream in_stream;
	
	in_stream.open("6-1-2.cpp"); 
	in_stream.get(character);
	for (count = 0 ; ! in_stream.fail() && count < MAXIMUM_FILE_LENGTH ; count++) 
	{
		file[count] = character;
		in_stream.get(character);
	}
	in_stream.close();
	
	while (count > 0) //count is now at last character of array
	{	
		cout << file[--count];
	}
}
\end{minted}
\caption{Code that reads itself in and prints out to screen using streams and arrays}
\label{source_code}
\end{listing}



%-----------------------------------------------------
\subsection{Arrays as parameters of functions}
You can simply use an array as a parameter in a function. Often you specify two parameters, one is the
array and the second is the length of the array - see example. Array parameters are effectively reference
parameters - no copy of the array is made and hence can be permanently changed within the function.

\begin{itemize}
	\item In the declaration and definition of the function you need two parameters:
	\begin{enumerate}
		\item The parameter of the array requires the correct base type (e.g. double)
		and requires empty squarebrackets (note if we would include a number in the brackets the compiler
		would ignore it).
		\item Second parameter needs to be an `int' which gives the size of the array.	
	\end{enumerate}
	
	\item To call the function we need to declare the array of the correct base type and the
	arguments are passed as:
	\begin{enumerate}
		\item Name of the array without the squarebrackets.
		\item Size (i.e. length of the array).
	\end{enumerate}
	
\end{itemize}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
double average(int some_array[], int length_of_the_array)
{
	int total = 0;
	for (int count = 0; count < length_of_the_array; count++)
	{
		total += some_array[count];
	}
	return (total/length);
}
\end{minted}
\caption{Array as parameter of a function}
\label{source_code}
\end{listing}

Therefore, we could just pass the array we wish to alter as parameter to a void function. In the below we
permanently change the array \emph{total}. Also with by using the \emph{const} modifier on the first and
second array we guarantee that they will not be changed by the function (this is a useful safety measure).

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void add_lists(const int first[], const int second[], int total[], int length)
{
	int count;
	for (count = 0 ; count < length ; count++)
		total[count] = first[count] + second[count];
}
\end{minted}


%-----------------------------------------------------
\subsection{Function that returns an array}
!!! NEED TO WIRTE THIS NEATLY !!! but \ldots

\begin{itemize}
	\item Since arrays as parameters to functions are effectively reference parameters (w/o explicitly writing the \&,
	you could just make a void function and change the array within it.
	\item Make a function that returns a dynamic pointer (an address on the heap).
	\item Declare a local pointer variable in the frame where the function will be called and then \ldots
\end{itemize}





%-----------------------------------------------------
\subsection{Sorting arrays using the selection sort}

\subsubsection*{The algorithm in words}
\begin{enumerate}
	\item At every current position of an array (and starting at 0) \ldots
	\begin{itemize}
		\item find the minimum
		\item swap it with the current position
		\item go to next position at array
		\item end when the array ends
	\end{itemize}
	\item Where the minimum function should return the index of the min.
	\item Use a swap function that swaps the two values of the indices (min and current).
\end{enumerate}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void sort_array(int array[], int length);
int find_min_index(int array[], int position, int length);

int main()
{
    int array[3] = {2, 3, 1};
    sort_array(array, 3);
}

void sort_array(int array[], int length)
{
    for (int i = 0; i < length; i++)
    {
        int min = 0;
        min = find_min_index(array, i, length);
        
        swap(array[i], array[min]);
    }
}

int find_min_index(int array[], int position, int length)
{
    int min_index = position;
    
    for (int i = min_index; i < length; i++)
    {
        if (array[i] < array[min_index])
        {
            min_index = i;
        }
    }
    return min_index;
}

void swap_values(int current_index, int min_index)
{
    int temporary_value;
    
    temporary_value = current_index;
    current_index = min_index;
    min_index = temporary_value;
}
\end{minted}
\caption{Selection sort}
\label{source_code}
\end{listing}


%-----------------------------------------------------
\subsection{Sorting arrays using the bubble sort}
Bubble sort used two loops where the first loops from the last element up until (but excluding)
the first element. Let the current index (at first iteration the last index) be i.

In the second loop you always start at the beginning and compare the value at index 0 with the
one at 0+1 \ldots 0+1 with 0+2 etc. If the value at 0 is larger than the one at 1, then swap the two.
Stop the loop when it has reached i from the first loop.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void bubbleSort(int array[], int length)
{
    int temp;
    for (int i = length - 1; i > 0; i--)
    {
        for (int j = 0; j < i; j++)
        {
            if (array[j] > array[j+1])
            {
                temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
            }
        }
    }
}
\end{minted}
\caption{Bubble sort}
\label{source_code}
\end{listing}


%-----------------------------------------------------
\subsection{Multi dimensional arrays}
Often used for screen bitmaps or n x m matrices of integers. Other examples can be a chess-board or sudoku.
A multidimensional array is just an array of arrays.

\subsubsection*{Example of a 2D array}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
double two_D_array[3][6];
	//Is an array with 3 rows and 6 columns
	//Think of it as being a 1D array of size 3 whose base type is a one dimensional array
	//of doubles of size 6
\end{minted}

\subsubsection*{2D as parameter of function}
The length of the first dimension (rows) is not given inside the brackets, but the size of all other
dimensions is given in the brackets - see below.
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void some_function{int bitmap[][nr_of_columns], int nr_of_rows};
\end{minted}

\subsubsection*{Looping over a 2D array}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
double two_D_array[3][6];
for (int row = 0; row < 3; row++)
{
	for (int column = 0; column < 6; column++)
	{
		// Do something
	}
}
\end{minted}
\caption{Looping over each field of a 2D array}
\label{source_code}
\end{listing}




%-----------------------------------------------------
\subsection{C-strings}
C-string variables are arrays of chars with a sentinel string character \emph{\textbackslash0}. Hence, you
always need to reflect the sentinel character in the length, when creating a c-string. Even if you have other
characters after the sentinel character, these will be ignored by the string functions (shown below).

\subsubsection*{Declaration and assignment}
Declare it just like an array of chars. Can also be initialised just like other arrays - but cannot be assigned
and not compared using simple operators.

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
//Declare a c-string
char some_string[14];

//Initialise version 1
char some_string[14] = {'E', 'n', 't', 'e', 'r', ' ', 'a', 'g', 'e', ':', ' ', '\0'};

//Initialise version 2 (is equivalent)
char some_string[14] = "Enter age: ";

//Initialise version 3 (omitting the length, makes an array that is just large enough)
char some_string[] = "Enter age: ";
\end{minted}


When looping through a c-string it is good to add the following safety measures \ldots
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
char my_name = "Alex";
for (int i = 0; (i != '\0' && i < SIZE); i++)
{
	//do something
}
\end{minted}


\subsubsection*{Predefined functions}
The below functions are contained in the \emph{c-string} library.

\begin{table}[h]
\begin{center}
\renewcommand{\arraystretch}{1.8}
\begin{tabular}{ m{7cm} m{1.5cm} m{6cm} } %!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\textbf{Function} & \textbf{Return type} & \textbf{Description}\\
\hline

strcpy(a\_string, b\_string) & void & Copies the string value stored in \emph{b\_string} onto \emph{a\_string}.
But beware, that the a string is large enough to contain the b string. You can use also a text like 
\emph{``Some text here!!!''} instead of \emph{b\_string}.\\
\hline

strncpy(a\_string, b\_string, limit) & void & Same as above but copies at most as many characters as
specified with the int \emph{limit}.\\
\hline

strlen(a\_string) & int &Returns the length of the string excluding the the sentinel character (not counted).\\
\hline

strcmp(a\_string, b\_string) & int & Returns 0 if the two string arguments are the same, a negative number
if a string is smaller than b string, and positive if it is the other way round.\\
\hline

strcat(a\_string, b\_string) & void & Concatenates the b string onto the a string. Beware that the
a string is large enough to contain both strings.\\
\hline

strncat(a\_string, b\_string, limit) & void & Same as above but appends at most \emph{limit} characters.\\
\hline

\end{tabular}
\end{center}
\caption{C-string functions in cstring library header}
\label{table_1}
\end{table}

\subsubsection*{String input using \emph{getline( \ldots )}}
Can use the getline function for user input on the standard input-stream and all other input-streams.
Getting an input with the operator \textgreater\textgreater assumes the input is complete when the
first empty space character is encountered. For example, cin \textgreater\textgreater Rob Miller, will
only get `Rob'. However, using cin.getline(some\_string, 80), will allow the user to type in a string
of up to 79 characters. The function \emph{getline} reads up to the sentinel character.

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
ifstream in_stream;
in_stream.getline(a_string, 80);
\end{minted}

The example below illustrates the use of c-string functions and getline.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
#include <cstring>

const int MAXIMUM_LENGTH = 80;

int main()
{
	char first_string[MAXIMUM_LENGTH];
	char second_string[MAXIMUM_LENGTH];
	
	cout << "Enter first string: ";
	cin.getline(first_string,MAXIMUM_LENGTH);
	cout << "Enter second string: ";
	cin.getline(second_string,MAXIMUM_LENGTH);

	cout << "Before copying the strings were ";
	if (strcmp(first_string,second_string)) 
		cout << "not ";
	cout << "the same.\n";

	strcpy(first_string,second_string);

	cout << "After copying the strings were ";
	if (strcmp(first_string,second_string)) 
		cout << "not ";
	cout << "the same.\n";
	
	strcat(first_string,second_string);

	cout << "After concatenating, the first string is: " << first_string;
}
\end{minted}
\caption{Illustration of c-string functions an getline( \ldots )}
\label{source_code}
\end{listing}


\subsubsection*{C-string as parameter to a function}
Same logic as for arrays but particular care has to be taken not to overwrite the sentinel character.

\subsubsection*{C-string to number conversion}
\begin{itemize}
	\item Use the functions \emph{atoi}, \emph{atol}, and \emph{atof} to convert a c-string variable to an integer,
	long, or double, respectively.
	\item These functions require the header-file \emph{cstdlib}.
	\item if the argument is such that the conversion cannot be made then the function returns zero.
\end{itemize}

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
//Example
int x = atoi("676");
double y = atof("#546.3");
\end{minted}

\subsubsection*{Good illustrative example of manipulating and working with c-strings (book)}
\begin{itemize}
	\item Uses call by reference parameters.
	\item Input using get and \textgreater\textgreater.
	\begin{itemize}	
		\item Shows that if you prompt user to type something and after that (before
		using cin \textgreater\textgreater or get you call a new void function - then in stackframe
		of new function you use cin \textgreater\textgreater etc. - then whatever you type in will be assigned to 
		a variable within this new stackframe.
	\end{itemize}
	\item Illustrates how to get rid characters that are no digits within a c-string variable (uses \emph{isdigit}).
	\item Illustrates design of function that prompts user to change his input up until the user says he's happy.
\end{itemize}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
// MAIN PART AND FUNCTION DECLARATIONS
#include <iostream>
#include <cstdlib>
#include <cctype>

using namespace std;

void get_user_input(int& input_number);
//gets user to input a number

void read_and_clean(int& n);
// Reads a line, discards all symbols that are no digis
// Converts the string to an integer and sets n equal to the value
// of this integer

void new_line();
//Discards all the input remaining on the current input line
//Also discards the '\n' at the end of the line

//---------------
int main()
{
    int n;
    
    get_user_input(n);
    cout << "Final value read in = " << n << endl;
    
    return 0;
}
\end{minted}
\caption{Long example of using c-strings 1/4}
\label{source_code}
\end{listing}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
// FUNCTION: get_user_input
void get_user_input(int& input_number)
{
    char ans;
    do
    {
        cout << "Enter an integer and press RETURN: ";
        
        read_and_clean(input_number);
        
        cout << "You entered: " << input_number;
        cout << " ... fine? ";
        cin >> ans;
        cin >> ans;
        new_line();
        
    } while ( (ans != 'y') && (ans != 'Y') );
    
}
\end{minted}
\caption{Long example of using c-strings 2/4}
\label{source_code}
\end{listing}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
//FUNCTION: read_and_clean
void read_and_clean(int& n)
{
    const int SIZE = 6;
    char digit_string[SIZE];
    
    char next;
    int index = 0;
    
    cin.get(next); // reads in next 'char' even if its a whitespace
    
    while ( next != '\n')
    {
        if ((isdigit(next)) && (index < (SIZE - 1)))
        {
            digit_string[index] = next;
            index++;
        }
        cin.get(next);
    }
    digit_string[index] = '\0';
    n = atoi(digit_string);
}
\end{minted}
\caption{Long example of using c-strings 3/4}
\label{source_code}
\end{listing}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
// FUNCTION new line
void new_line()
{
    char symbol;
    do
    {
        cin.get(symbol);
    } while (symbol != '\n');
}
\end{minted}
\caption{Long example of using c-strings 4/4}
\label{source_code}
\end{listing}




