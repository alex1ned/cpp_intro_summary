\section{The standard \emph{string} class}

%------------------------------------------------------------
\subsection{Introduction to the string class}
\begin{itemize}
	\item The class \emph{string} is defined in the library \emph{string} and the definitions are placed in the 
	std namespace.
	\item Can assign a string variable with = (note that with c-strings we cannot assign but only initialise).
	\item Can concatenate using +.
\end{itemize}

\subsubsection*{Simple example}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
#include <string> //needs to be included
using namespace std; //required

int main()
{
	string phrase; // initialised to empty string w. default constructor
	string adjective("fried"), noun("ants"); // initialise two string
    
	//Use overloaded operators '=' and '+' to assign a new string value to phrase
	phrase = "I love " + adjective + " " + noun << endl;
}
\end{minted}
\caption{Basic handling of string objects}
\label{source_code}
\end{listing}


%------------------------------------------------------------
\subsection{I/O with the string class}
I/O is very similar to c-strings but the \emph{geline} function differs.
\begin{itemize}
	\item Use \textless\textless{} on output streams.
	\item Use \textgreater\textgreater{} on input streams (as before you only read in a string up
	to, and excluding, the next whitespace).
	\item Use function \emph{getline} to input an entire line of text into a string object.
	\begin{itemize}
		\item Syntax differs from c-string variables: \emph{getline(in\_stream, string)}.
		\item getline( \ldots ) stops reading when it encounters the end-of-line marker \textbackslash n.
	\end{itemize}
\end{itemize}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
string greeting("Hello"), response, next_word;
cout << greeting <<endl;

getline(cin, response); // gets entire line
cin >> next_word; // only gets text up to next white-space
\end{minted}
\caption{I/O with string objects}
\label{source_code}
\end{listing}


\begin{itemize}
	\item If you want to read in up to a certain character use the following syntax \ldots
	\begin{itemize}
		\item \emph{getline(inStream, stringToWriteTo, charWhereToStop);}
		\item e.g. stop reading when `?' is encountered: \emph{getline(cin, question, `?');}
	\end{itemize}
\end{itemize}


\subsubsection*{Short illustrative example}
\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
#include <string>

void new_line();

int main()
{
	string first_name, last_name, record_name;
	string motto = "Your records are our records.";
    
	cout << "Enter your first and last name:\n";
	cin >> first_name >> last_name; // Reads in first and last name separated by whitespace
    
	new_line(); // call to function 'new_line'
    
	//String concatenation and assignment works with overloaded operators
	record_name = last_name + ", " + first_name;
   
	cout << "Please suggest a better motto:\n";
	getline(cin, motto); // read in new string from keyboard and assign it to motto
}

void new_line()
{
	char next_char; //declare a character variable
	do
   	 {       
		cin.get(next_char); // gets some character until the character
		//is the new line character
	} while (next_char != '\n');
}
\end{minted}
\caption{Short illustrative example of handling string objects}
\label{source_code}
\end{listing}

Note that when mixing \textgreater\textgreater and getline( \ldots ), you may encounter the problem that
\textgreater\textgreater only leaves a `\textbackslash n' in the line. When getline( \ldots ) comes in, it may only
see the `\textbackslash n' and then stop. To avoid this problem to happen us either of the two \ldots
\begin{itemize}
	\item The new\_line function from the previous example.
	\item The function \emph{ignore} from the iostream library
	\begin{itemize}
		\item cin.ignore(1000, `\textbackslash n');  
		\item Will read and discard the entire rest of the line up to and including the `\textbackslash n' \ldots
		\item or until it discards 1000 characters if it does not find the end of the line after 1000 characters.
	\end{itemize}
\end{itemize}



%------------------------------------------------------------
\subsection{Member functions of the class string}
\subsubsection*{Member function \emph{at(integer)}}
Checks if \emph{integer} evaluates to an illegal index.

The following table is an illustration of some commonly used functions of the string class.

\begin{table}[H]
\begin{center}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{m{6cm} m{9cm}}
\textbf{Function} & \textbf{Description}\\
\hline

\textbf{Accessors} &\\
str[i] & Returns read/write reference to character in \emph{str} at index i.\\

str.at(i) & Returns read/write reference to character in str at index i. Same as str[i],
but this version checks for illegal index.\\

str.substr(position, length) & Returns the substring of the calling object starting at \emph{position}
and having \emph{length} characters.\\

str.length() & Returns the length of str.\\

\hline
\textbf{Assignment/Modifiers} &\\
str1 = str2; & Initialises str1 to str2's data.\\

str1 += str2; & Character data of str2 is concatenated to the end of str1.\\

str.emphy() & Returns \emph{true} if str is an empty string and false otherwise.\\

str1 + str2 & Returns a string that has str2's data concatenated to the end of str1's data.\\

str.insert(pos, str2); & Inserts str2 into str beginning at position pos.\\

str.erase(pos, length); & Removes substring of size length, starting at position pos.\\

\hline
\textbf{Comparison} &\\
str1 == str2 OR str1 != str2 & Compare for equality or inequality; returns a bool value.\\

str1 < str2 OR str1 >= str2 & Lexocographical comparison.\\

\hline
\textbf{Finds} &\\
str.find(str1) & Returns index of the first occurrence of str1 in str. If str1 is \emph{not} found,
then the special value \emph{string::npos} is returned.\\

str.find(str1, pos) & Returns index of the first occurence of string str1 in str; the search
starts at position \emph{pos}.\\

str.find\_first\_of(str1, pos) & Returns the index of the first instance in str of any character in
str1, starting the search at position \emph{pos}.\\

str.find\_first\_not\_of(str1, pos) & Returns the index of the first instance in str of any character
not in str1, starting the search at position \emph{pos}.\\

\hline
\end{tabular}
\end{center}
\caption{Commonly used member functions of string class}
\label{table_1}
\end{table}



%------------------------------------------------------------
\subsection{Converting from string objects}
There is no automatic conversion of string objects to c-strings. We must explicitly perform the type conversion
which can be done with the string member function \emph{c\_str()}. Also given the = operator does not
work on c-strings we need to copy the value of a string object to a c-string with \emph{strcpy}.

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
//For example
strcpy(c_string, string_object.c_str());
\end{minted}

\subsubsection*{Converting to numbers}
\begin{itemize}
	\item Use \emph{stof}, \emph{stod}, \emph{stoi}, or \emph{stol} to convert a string to a float, double, int, or long.
	\item Use \emph{to\_string} to convert a number type to a string.
\end{itemize}

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
//For example
int i;
string s;

i = stoi("35"); // converts string "35" to an integer 35
s = to_string(2.5 * 2); // converts 5.0 to a tring
\end{minted}








