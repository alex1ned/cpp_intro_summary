\section{Linked lists and binary trees}
You implement linked lists and binary trees usually using struct or also class objects. These
objects have various data members -- one of these members is a pointer to the next node.


%----------------------------------------------------------------
\subsection{Basics of linked lists}
The linked list is then a list of nodes where you have one pointer pointing to the first
node, and each node has a member pointer that points to the next node. Finally the 
member pointer of the last node points to NULL.

Particular care needs to be taken not to lose nodes so not to have memory leaks.


%----------------------------------------------------------------
\subsection{Basics steps to build linked lists}

\subsubsection*{Set up struct and first node}
\begin{enumerate}
	\item Create struct object.
	\item Declare a head pointer that points to the first node.
	\item Assign this variable to a \emph{dynamic node} using the new operator.
	\item Give this first node values - also setting the pointer to the next node to NULL.
\end{enumerate}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
//The structure of a node
struct Node
{
	int data;
	Node* link; //pointer to next node
};

//Headpointer
Node* head;
head = new Node;

//Assign values to the data members
head->data = 3;
head->link = nullptr;
\end{minted}
\caption{Set up a linked list}
\label{source_code}
\end{listing}

\subsubsection*{Insert a node at the beginning}
\noindent
The steps such a function should perform are as follows \ldots
\begin{enumerate}
	\item Create a new dynamic node (this is referred to using the dereferencing operator).
	\item Assign the values to the data members of the node.
	\item Make the pointer of this new node point to the (current) \emph{head} node.
	\begin{itemize}
		\item Set the variable equal to the value of the \emph{head pointer}.
	\end{itemize}
	\item Make head pointer point to the new node.
\end{enumerate}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void headInsert(Node*& head, int theNumber)
{	//head is a pointer that is used as a call by reference parameter ...
	
	//Declare the new node
	Node* temporary_pointer;
	temporary_pointer = new Node;
	
	//Assign member variables
	temporary_pointer->data = theNumber;
	temporary_pointer->link = head; //now the pointer in the new node
		//points to the node that was previously at start
	
	//Make the head pointer point to the new node
	head = temporary_pointer;
}
\end{minted}
\caption{Add a node at the beginning of a linked list (as function)}
\label{source_code}
\end{listing}

\subsubsection*{Empty list}
To indicate that linked list is empty, set the head pointer to NULL. When creating
functions that manipulate linked lists, also check if they work when the list is empty.



%----------------------------------------------------------------
\subsection{Using the pointer in the nodes as iterators}

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
Node* iter; //a pointer to variables of type 'Node'

for (iter = head; iter != NULL; iter = iter->link)
{
	//For every node (i.e. for every pointer that points
	//to a node) ...
	//... until the pointer is a NULL (i.e. at end of linked list) ...
	
	//Do something
	
	//And then reset the pointer to the address in that node
}
\end{minted}
\caption{Using pointer as the iterator in a linked list}
\label{source_code}
\end{listing}



%----------------------------------------------------------------
\subsection{Searching a linked list}
Use the following function definition that returns the pointer to the node that contains
the target value we are looking for.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
//Use same node definition as in previous example
#include <cstdef>

Node* search(Node* head, int target)
{
	Node* here = head; //here now points to start

	//If the list is empty
	if (here == nullptr) 
	{
		return nullptr;
	}

	//If list includes at least one node
	else
	{
		while (here->data != target && here->link != nullptr)
		{
			here = here->link;
		}
		if (here->data == target)
		{
			return here;
		}
		else
		{
			return nullptr;
		}
	}
}
\end{minted}
\caption{Searching a linked list}
\label{source_code}
\end{listing}



%----------------------------------------------------------------
\subsection{Inserting and removing nodes within a list}


\subsubsection*{Insert after a specific node}
The code below works for inserting at end and middle but not at the beginning of the linked list.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void insert(Node* after_me, int the_number)
{
	Node* temporary_ptr;
	temporary_ptr = new Node;
	
	temporary_ptr->data = the_number;
	temporary_ptr->link = after_me->link;
	
	after_me->link = temporary_ptr;
}
\end{minted}
\caption{Insert a node after a specific node within a linked list}
\label{source_code}
\end{listing}


\subsubsection*{Removing a node}
!!! To be checked from Will's notes !!!




%----------------------------------------------------------------
\subsection{Double linked list}
In such lists, nodes have two links -- one points to the next node and the other points to
the previous node. Also we not only have a \emph{head} pointer that points to the first
node, but we also have a \emph{rear} pointer that points to the last node.

\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
struct Node
{
	int data;
	Node* forward_link;
	Node* backward_link;
};
Node* head;
Node* rear;
\end{minted}
\caption{Structure of a double linked list}
\label{source_code}
\end{listing}



%----------------------------------------------------------------
\subsection{Intro to binary trees}
Binary trees are not linked lists per se but they use the same basic concept of being
nodes that consist pointers that point to other nodes. For trees, you have a root pointer
that points to the first (the root) node of the tree. Each node then has one pointer pointing to
the left and one pointing to the right (i.e. at each level the tree is doubling).


\begin{listing}[H]
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
struct TreeNode;
{
	int data;
	TreeNode* leftLink;
	TreeNode* rightLink;
};
\end{minted}
\caption{Basic structure of a binary tree}
\label{source_code}
\end{listing}



%----------------------------------------------------------------
\subsection{Routines from lecture slides}
\subsubsection*{Set up node}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
struct Node
{
	char word[80];
	Node* next;
};
\end{minted}

\subsubsection*{Initialise linked list}
Sets up an empty list.
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void initialise_list(Node*& front, Node*& rear)
{
	front = rear = nullptr;
}
\end{minted}


\subsubsection*{Create new node}
Returns a pointer to a new node and the pointer within the node is set to NULL.
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
Node* create_new_node(const char* constents)
{
	Node* new_node = new (nothrow) Node;
	assert(new_node != NULL);
	
	strcpy(new_node->word, contents);
	new_node->next = NULL;
	return new_node;
}
\end{minted}

\subsubsection*{Count items in list}
Returns an integer that is the number of items in list.
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
int count_items(Node* front)
{
	int length = 0;
	for (Node* current = front; current; current = current->next)
	{
		length++;
	}
	return length;
}
\end{minted}


\subsubsection*{Add a node at front of the list}
Note that if \emph{front} is NULL the boolean expression \emph{if (front)} would evaluate
to false (given false is 0). Hence the boolean expression \emph{if (!front)} tests if the list is
empty (i.e. when front equals the NULL).

\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void add_to_front(Node*& front, Node*& rear, const char* word)
{
	Node* item = create_new_node(word);
	
	//Case if list is empty
	if (!front)
	{
		front = rear = item;
		return;
	}
	
	//Default case (if there are items in the list)
	item->next = front;
	front = item;
}
\end{minted}


\subsubsection*{Add a node at rear of the list}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void add_to_rear(Node* front, Node*& rear, const char* word)
{
	Node* item = create_new_node(word);
	
	//Empty list
	if (!front)
	{
		front = rear = item;
		return;
	}
	
	//Default case
	rear->next = item;
	rear = item;
}
\end{minted}


\subsubsection*{Add a node in a sorted list}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void add_sorted(Node*& front, Node*& rear, const char* new_word)
{
	Node* p = front;
	Node* q = rear;
	
	//Find the node after which you wish to insert
		//For every pointer starting at the beginning...
		//... until is NULL & the word in the node is alphabetically smaller
		//than the word we want to insert as node.		
	for (p = front; p && (strcmp(p->word, new_word) < 0); p = p->next)
	{
		q = p;
	}
	//q now points to the node we wish to insert AFTER
	//p now points to the node we wish to insert BEFORE
	
	//In case we need to add it to the front (i.e. the new node comes alphabetically first)
	if (q == nullptr)
	{
		add_to_front(front, rear, new_word);
		return;
	}
	
	//In case we need to add it to the rear (i.e. the new node comes alphabetically last)
	if (p == nullptr)
	{
		add_to_rear(front, rear, now_word);
		return;
	}
	
	//Otherwise create the new node and insert it after q and before p
	new_node->next = p;
	q->next = new_node;	
}
\end{minted}


\subsubsection*{Print the list to the screen}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void print_list(Node* front)
{
	for (Node* current = front; current; current = current->next)
	{
		cout << "[" << current->word << "]" << endl;
	}
	cout << endl;
}
\end{minted}


\subsubsection*{Print one element of the list}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void print_element(Node* front, int item_number)
{
	int count = 0;
	Node* current;
	
	for (current = front; current && count < item_number; current = current->next)
	{
		count++;
	}
	
	if (current)
	{
		cout << "The current word is: " << current->word << endl;
	}
}
\end{minted}


\subsubsection*{Print list backwards (recursively)}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void print_list_backwards(Node* front)
{
	//Base case
	if (!front)
	{
		return;
	}
	
	//Recursive step
	print_list_backwards(front->next);
	cout << "The word is " << front->word << endl;
}
\end{minted}


\subsubsection*{Print list backwards (iteratively)}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void print_list_backwards(Node* front)
{
	int count = count_items(front);
	for (int target = count - 1; target >= 0; target--)
	{
		print_element(front, target);
	}
	cout << endl;
}
\end{minted}


\subsubsection*{Delete a node containing the target string}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void delete_node(Node*& front, Node*& rear, const char* target)
{
	Node* p = front;
	Node* q = rear;
	
	for (p = front; p && strcmp(p->word, target); p = p->next)
	{
		q = p;
	}
	//q now points to the node BEFORE the one we want to delete
	//p points to the node we wish to delete
	
	if (p == nullptr)
	{
		cout << "Could not find the word " << target << endl;
		return;
	}
	
	// !!! Store the target's 'next' pointer
	Node* link = p->next;
	delete p;
	
	//Case if target is the front (i.e. q is NULL)
	if (p == front)
	{
		front = link;
		if (front == nullptr)
		{
			rear = nullptr;
		}
		return;
	}
	
	//Update the next pointer of the node before the one being deleted
	q->next = link;
	
	//Handle case that the target is the rear
	if (p == rear)
	{
		rear = q;
	}	
}
\end{minted}


\subsubsection*{Delete all nodes in the list}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void delete_list(Node*& front, Node*& rear)
{
	while (front != nullptr)
	{
		Node* link = front->next;
		delete front;
		front = link;
	}
	rear = nullptr;

}
\end{minted}



%----------------------------------------------------------------
\subsection{Binary trees -- lecture routines}
Note for the below you need to declare a root node in the main function (clearly after
the struct for the nodes has been declared).
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
Node* root = nullptr;
\end{minted}


\subsubsection*{Set up the struct}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
struct Node
{
	int number;
	Node* left;
	Node* right;
};
\end{minted}


\subsubsection*{Create a new node}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
Node* create_new_node(Node* l, Node* r, int value)
{
	Node* item = new Node;
	assert(item);
	item->number = value;
	item->left = l;
	item->right = r;
	
	return item;
}
\end{minted}


\subsubsection*{Insert -- uses pass by value for root (recursive)}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
Node* insert(Node* root, int value)
{
	if (!root)
	{
		root = create_new_node(value, nullptr, nullptr)
	}
	
	if (root->number == value)
	{
		return root;
	}
	
	if (value < root->number)
	{
		root->left = insert(root->left, value);	
	}
	
	else
	{
		root->right = insert(root->right, value);
	}
	return root;
}
\end{minted}


\subsubsection*{Output the tree (recursive)}
\begin{minted}
[frame=lines, linenos, fontsize=\small, obeytabs=true, tabsize=3]{c++}
void output(Node* current)
{
	if (current)
	{
		output(current-> left);
		cout << current->number << " ";
		output(current->right);	
	}
}
\end{minted}








